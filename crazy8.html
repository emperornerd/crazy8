<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♠</text></svg>">
<title>Crazy Eights / UNO / War Hybrid</title>
<style>
  :root{
    --bg:#0b1220;
    --card-bg:#fff;
    --accent:#ffbe4b;
    --muted:#9aa7b2;
    --panel:#0f1720;
    --red:#D92D20;
    --green: #2E7D32;
    --blue: #0277BD;
    --yellow: #FFC107;
    --black: #111;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,#061021 0%, #071428 60%);color:#e6eef6;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;box-sizing:border-box}
  .app{width:100%;max-width:1100px; display: flex; flex-direction: column; height: 100%; max-height: 900px;}
  
  header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:12px;flex-wrap:wrap;flex-shrink:0}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:16px;align-items:center;flex-wrap:wrap; justify-content: flex-end;}
  .control-group{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  
  button{background:var(--accent);border:0;color:#052026;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.secondary, label.secondary, select.secondary {background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px; border-radius:8px; display:inline-flex; align-items:center; gap: 4px; font-size: 13px; font-family: inherit;}
  select.secondary { padding: 7px 10px; background: var(--panel); }
  label.secondary input { margin-right: 4px; }
  button:disabled{opacity:0.5;cursor:not-allowed;}

  .board{
    display:grid;
    grid-template-rows: auto 1fr;
    gap:18px;
    flex-grow: 1;
    min-height: 0;
  }
  
  .top-row { 
    display: grid; 
    grid-template-columns: 300px 1fr; 
    gap: 18px; 
  }
  
  .center-row { 
    display: grid;
    grid-template-columns: auto 1fr; 
    gap: 18px;
    min-height: 0;
  }

  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6); display: flex; flex-direction: column; min-height: 0;}
  .area{min-height:160px}
  /* Desktop Hand: Wrap, No scroll */
  .hand{display:flex;gap:6px;flex-wrap:wrap; padding: 4px; transition: opacity 0.2s; overflow-x: visible;} 
  
  .card{
    width:75px;height:107px;
    border-radius:8px;background:var(--card-bg);color:var(--black);display:flex;flex-direction:column;justify-content:space-between;padding:8px;box-shadow:0 6px 18px rgba(2,6,23,0.5);cursor:pointer;
    user-select:none;font-weight:700; border: 2px solid var(--card-bg); flex-shrink: 0; transition: all 0.2s;
    box-sizing: border-box; 
    position: relative; 
  }
  .card .suit{font-size:30px;line-height:0.9}
  .card .rank{font-size:20px}
  
  /* New Corner Rank Styles for Wilds */
  .card .corner-tl { position: absolute; top: 6px; left: 8px; font-size: 20px; line-height: 1; font-weight: 800; }
  .card .corner-br { position: absolute; bottom: 6px; right: 8px; font-size: 20px; line-height: 1; font-weight: 800; transform: rotate(180deg); }

  .card.back{background:linear-gradient(180deg,#3a4a63,#253046);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:800; border: none;}
  
  .card.small{width:54px;height:78px;border-radius:6px;padding:4px;font-size:12px; border: none;}
  .card.small .suit{font-size: 20px;}
  .card.small .rank{font-size: 16px;}

  #opponentCardCount {
    font-size: 24px;
    font-weight: 800;
    align-items: center;
    justify-content: center;
    line-height: 1;
    color: white;
    width: 40px;
    height: 58px;
  }
  
  .hand.size-m .card { width: 66px; height: 94px; }
  .hand.size-m .card .suit { font-size: 24px; }
  .hand.size-m .card .rank { font-size: 16px; }
  .hand.size-m .card.uno .rank { font-size: 20px; }
  .hand.size-m .card.uno .suit { display: none; }

  .hand.size-l .card { width: 50px; height: 72px; padding: 4px; border-radius: 4px; }
  .hand.size-l .card .suit { font-size: 18px; }
  .hand.size-l .card .rank { font-size: 14px; }
  .hand.size-l .card.uno .rank { font-size: 16px; }
  .hand.size-l .card .corner-tl, .hand.size-l .card .corner-br { font-size: 16px; top: 2px; left: 4px; }
  .hand.size-l .card .corner-br { bottom: 2px; right: 4px; }
  .hand.size-l .card.uno .suit { display: none; }
  
  /* Size XL: Smallest card for max efficiency */
  .hand.size-xl .card { width: 40px; height: 58px; padding: 2px; border-radius: 3px; }
  .hand.size-xl .card .suit { font-size: 14px; }
  .hand.size-xl .card .rank { font-size: 12px; }
  .hand.size-xl .card.uno .rank { font-size: 12px; }
  .hand.size-xl .card .corner-tl, .hand.size-xl .card .corner-br { font-size: 12px; top: 2px; left: 2px; }
  .hand.size-xl .card .corner-br { bottom: 2px; right: 2px; }


  .card[data-suit="♥"], .card[data-suit="♦"] { color: var(--red); }
  .suit-btn[data-suit="♥"], .suit-btn[data-suit="♦"] { color: var(--red); }
  
  .card.uno { border-width: 2px; }
  .card.uno .rank { font-size: 24px; font-weight: 800; text-align: center; margin: auto; } 
  .card.uno .suit { display: none; }
  .card[data-color="R"] { background-color: var(--red); color: white; border-color: white; }
  .card[data-color="G"] { background-color: var(--green); color: white; border-color: white; }
  .card[data-color="B"] { background-color: var(--blue); color: white; border-color: white; }
  .card[data-color="Y"] { background-color: var(--yellow); color: var(--black); border-color: var(--black); }
  
  .card.wild { background: linear-gradient(135deg, var(--red) 25%, var(--yellow) 25%, var(--yellow) 50%, var(--blue) 50%, var(--blue) 75%, var(--green) 75%); color: white; border-color: white; }
  .card.wild .rank { background: rgba(0,0,0,0.6); border-radius: 4px; padding: 2px 8px; }

  .suit-btn[data-color="R"] { background: var(--red); color: white; }
  .suit-btn[data-color="G"] { background: var(--green); color: white; }
  .suit-btn[data-color="B"] { background: var(--blue); color: white; }
  .suit-btn[data-color="Y"] { background: var(--yellow); color: var(--black); }
  
  .wild-suit-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px; 
    font-weight: 800;
    line-height: 1;
    padding: 6px 12px; 
    border-radius: 12px;
    background: rgba(255,255,255,0.9);
    color: var(--black);
    border: 3px solid var(--black);
    pointer-events: none;
    text-shadow: none;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    z-index: 10;
  }
  /* Specific colors for the indicator */
  .wild-suit-indicator[data-color="R"] { background: var(--red); color: white; border-color: white; }
  .wild-suit-indicator[data-color="G"] { background: var(--green); color: white; border-color: white; }
  .wild-suit-indicator[data-color="B"] { background: var(--blue); color: white; border-color: white; }
  .wild-suit-indicator[data-color="Y"] { background: var(--yellow); color: black; border-color: black; }
  
  /* Crazy 8 Suit Indicator */
  .wild-suit-indicator[data-suit="♥"], .wild-suit-indicator[data-suit="♦"] { color: var(--red); border-color: var(--red); background: white; }
  .wild-suit-indicator[data-suit="♠"], .wild-suit-indicator[data-suit="♣"] { color: black; border-color: black; background: white; }

  .card.wild .wild-suit-indicator { 
    font-size: 28px; 
    padding: 4px 10px; 
  }

  .center-stack{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:18px; 
    padding: 12px;
  }
  .stack-row{
    display:flex;
    gap:16px;
    align-items:center
  }
  
  /* War Specific Layout */
  .war-battle-zone {
      display: flex;
      gap: 40px;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      min-height: 120px;
  }
  .war-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
  }
  .war-pot-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    background: rgba(0,0,0,0.2);
    padding: 8px;
    border-radius: 8px;
    width: 100%;
    max-width: 300px;
    height: 100px; /* FIXED HEIGHT TO PRE-EXPAND */
    overflow-y: auto;
    box-sizing: border-box;
  }
  .war-pot-visual {
    display: flex; 
    flex-wrap: wrap;
    align-items: center; 
    justify-content: center;
    margin-top: 4px;
    gap: 4px;
    width: 100%;
  }
  .war-mini-card {
    width: 28px; 
    height: 38px; 
    background: #fff; 
    border-radius: 3px; 
    color: #111;
    font-size: 10px;
    font-weight: 800;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    line-height: 1;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  .war-mini-card[data-suit="♥"], .war-mini-card[data-suit="♦"] { color: var(--red); }
  
  .war-pot-label {
      font-weight: 800;
      color: var(--accent);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: sticky;
      top: 0;
  }
  .war-last-result {
    font-size: 13px;
    color: var(--accent);
    font-weight: 600;
    text-align: center;
    min-height: 20px;
    margin-top: 10px;
    padding: 4px 8px;
    background: rgba(255, 190, 75, 0.1);
    border-radius: 6px;
  }
  
  .info{font-size:13px;color:var(--muted)}
  
  /* NEW: Status and Log Toggles */
  .mobile-toggle { display: none; }
  .status-content, .log-content { display: block; }
  
  /* Log Preview is now the Log Toggle (desktop only) */
  .log-toggle { 
    max-height: 80px; 
    min-height: 80px; 
    overflow: hidden; 
    font-size: 13px; 
    color: var(--muted); 
    cursor: pointer; 
    border-radius: 6px; 
    padding: 6px; 
    background: rgba(255,255,255,0.01); 
    margin-top: 8px;
    /* Hide on mobile, show on desktop */
    display: none; 
  }
  .log-toggle:hover { background: rgba(255,255,255,0.03); }
  .log-toggle div { margin-bottom: 2px; }
  .log-full { max-height: 400px; overflow-y: auto; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 13px; color: var(--muted); }
  
  .status{display:flex;gap:10px;align-items:center}
  .big-turn{font-size:16px;font-weight:700}

  .suit-btn{padding:8px 10px;border-radius:8px;border:0;cursor:pointer;font-weight: 600; min-width: 80px; text-align: center;}
  .suit-btn:focus{outline:2px solid rgba(255,255,255,0.08)}
  .muted{color:var(--muted)}
  
  .modal-overlay{display:none;position:fixed;z-index:100;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.6);backdrop-filter:blur(5px);align-items:center;justify-content:center}
  .modal-overlay.visible{display:flex}
  
  /* FIX: Remove blur for suit picker, keep screen dim */
  .modal-overlay.no-blur {
      backdrop-filter: none;
      background: rgba(0,0,0,0.8);
  }
  
  .modal-panel{background:var(--panel);border-radius:12px;padding:24px;box-shadow:0 10px 30px rgba(0,0,0,0.4);min-width:320px; max-width: 500px;}
  .modal-panel h2{margin:0 0 16px 0;font-size:18px}
  .modal-panel .settings-group{display:flex;flex-direction:column;gap:10px;margin-bottom:20px}
  .modal-panel .settings-group label{font-size: 14px; display: flex; justify-content: space-between; align-items: center;}
  .modal-panel .modal-footer{display:flex;justify-content:flex-end;align-items:center;margin-top:16px; gap: 8px;}
  .modal-panel .warning{font-size: 13px; color: var(--muted); margin-right: auto;}
  .modal-panel ul { margin-top: 0; padding-left: 20px; }
  .modal-panel li { margin-bottom: 8px; }
  
  #suitPickerButtons { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 20px; }


  @media (min-width:981px) {
    /* Desktop: Ensure log preview and full status content are visible by default */
    .log-toggle { display: block; }
  }

  @media (max-width:980px){
    
    /* Header adjustments for mobile */
    header { flex-direction: column; align-items: stretch; gap: 8px; margin-bottom: 8px; }
    h1 { text-align: center; font-size: 18px; }
    
    /* FIX: Allow controls to wrap and use smaller buttons */
    .controls { justify-content: center; flex-wrap: wrap; gap: 8px; }
    .control-group { 
      justify-content: center; 
      gap: 8px; 
    }
    .controls .control-group:first-child { order: 1; } 
    .controls .control-group:last-child { order: 2; } 
    
    header .controls button {
      padding: 5px 7px; /* Reduced from 6/8 */
      font-size: 11px; /* Reduced from 12 */
    }
    header .controls button.secondary {
      padding: 4px 6px; /* Reduced from 5/7 */
      font-size: 11px; /* Reduced from 12 */
    }
    
    /* Layout adjustments for mobile */
    .board{grid-template-rows: auto 1fr;}
    .top-row { 
      grid-template-columns: 1fr; 
      gap: 10px; 
      max-height: 30vh; 
    }
    .top-row > .panel {
      overflow-y: auto;
    }
    
    .center-row { 
      grid-template-columns: 1fr; 
      grid-template-rows: auto 1fr;
      min-height: 0; 
      gap: 10px;
    }
    .panel{padding:10px}
    .area{min-height: auto;}
    
    .center-stack {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    .center-stack .stack-row {
      gap: 12px;
    }
    .center-stack > div:last-child {
      margin-top: 0;
    }
    
    /* Mobile War Layout Adjustments */
    #warStack {
        width: 100%;
        gap: 10px;
    }
    .war-battle-zone {
        gap: 15px;
        margin-bottom: 5px;
    }
    /* Scale cards down slightly in battle zone on mobile */
    .war-battle-zone .card {
        width: 55px; height: 80px;
    }
    .war-battle-zone .card .rank { font-size: 16px; }
    .war-battle-zone .card .suit { font-size: 22px; }
    
    #opponentPanel {
      padding: 8px; 
    }
    #opponentPanel .big-turn {
      font-size: 14px; 
    }
    #opponentPanel .info {
      font-size: 12px;
    }
    #opponentCardCount {
      width: 30px;
      height: 44px;
      font-size: 18px;
    }
        
    /* MODIFIED: Switched to vertical scrolling for hand */
    #playerHand {
      flex-wrap: wrap; /* Allow cards to wrap */
      overflow-y: auto; /* Enable vertical scrolling */
      overflow-x: hidden; /* Disable horizontal scrolling */
      padding: 8px 4px;
      margin: 0;
      flex-grow: 1; /* Make hand fill vertical space */
      -webkit-overflow-scrolling: touch; 
      scrollbar-width: none; /* Hide scrollbar for Firefox */
      align-content: flex-start; /* Stack cards from the top */
    }
    #playerHand::-webkit-scrollbar {
      display: none; /* Hide scrollbar for Chrome, Safari, etc. */
    }
    
    /* Mobile War Deck Button */
    #playerHand .card.war-deck-btn {
        width: 80px !important;
        height: 110px !important;
        margin-top: 10px;
    }
    
    /* Force smallest card size on mobile to save vertical space */
    #playerHand .card:not(.war-deck-btn) { 
      width: 40px; 
      height: 58px; 
      padding: 2px; 
      border-radius: 3px; 
    }
    #playerHand .card:not(.war-deck-btn) .suit { font-size: 14px; }
    #playerHand .card:not(.war-deck-btn) .rank { font-size: 12px; }
    #playerHand .card:not(.war-deck-btn).uno .rank { font-size: 12px; }
    #playerHand .card:not(.war-deck-btn) .corner-tl, #playerHand .card:not(.war-deck-btn) .corner-br { font-size: 12px; top: 2px; left: 2px; }
    #playerHand .card:not(.war-deck-btn) .corner-br { bottom: 2px; right: 2px; }

    /* Mobile Status/Log Toggles */
    .mobile-toggle { 
        display: flex; 
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        cursor: pointer;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        font-weight: 600;
        margin-top: 4px;
        color: var(--muted);
    }
    .mobile-toggle span { display: flex; align-items: center; gap: 8px; }
    .toggle-content.collapsed { display: none; }
    
    #statusContent { display: none; }
    
    .log-toggle { display: none; }

    #logContent:not(.collapsed) .log-full { display: block; }

    /* --- WAR MODE SPECIFIC MOBILE OVERRIDES --- */
    .center-row.war-mode {
        display: flex;
        flex-direction: row;
        align-items: center;
    }
    
    /* The Hand Panel (Left) */
    .center-row.war-mode .panel.area {
        order: 1; /* First */
        flex: 0 0 auto; /* Don't grow */
        width: auto;
        background: none; 
        box-shadow: none; 
        padding: 0;
        border: none;
        min-height: 0;
    }
    
    /* The Battle Field (Right) */
    .center-row.war-mode .center-stack {
        order: 2;
        flex: 1; /* Take remaining space */
    }
    
    /* Fix the scrolling hand issue */
    .center-row.war-mode #playerHand {
        overflow: visible;
        padding: 5px;
        justify-content: center;
    }
    
    /* Adjust War Deck Btn Margin in this specific layout */
    .center-row.war-mode #playerHand .card.war-deck-btn {
        margin-top: 0;
    }
  }
</style>
</head>
<body>

<div class="app">
<header>
  <h1>Crazy Eights / UNO / War Hybrid</h1>
  <div class="controls">
    <div class="control-group">
      <button id="newGameBtn">New Game</button>
      <button id="hintBtn" class="secondary">Hint</button>
      <button id="cpuSpeedBtn" class="secondary">CPU: Normal</button>
    </div>
    <div class="control-group">
      <button id="rulesBtn" class="secondary">Rules</button>
      <button id="settingsBtn" class="secondary">⚙️ Settings</button>
    </div>
  </div>
</header>

<div class="board">
  
  <div class="top-row">
    <div class="panel area" id="opponentPanel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="big-turn" id="turnLabel">Turn: —</div>
          <div class="info"><span id="opponentLabel">CPU</span>: <span id="opponentInfo">waiting</span></div>
        </div>
        <div class="status">
          <div id="opponentCardCount" class="card back small">0</div>
          <div class="info" id="opponentHandLabel">P2 Hand</div>
        </div>
      </div>
      <div>
      </div>
    </div>
    
    <div class="panel">
      <div class="mobile-toggle" id="statusToggle">
        <span>Game Status: <span id="currentSuitPreview" style="font-weight: 700;">—</span></span>
        <span id="statusChevron">▼</span>
      </div>
      <div id="statusContent" class="toggle-content"> 
        <div class="info">Controls & status:</div>
        <div id="statusText" class="info muted" style="margin-top:4px">Game not started</div>
        <div id="currentSuit" class="info" style="margin-top:4px">Suit: —</div>
      </div>
      
      <div class="mobile-toggle" id="logToggle">
        <span>Game Log (Full)</span>
        <span id="logChevron">▼</span>
      </div>
      <div id="logContent" class="toggle-content collapsed">
        <div id="logPreview" class="log-toggle"></div>
        <div id="fullLogContent" class="log-full" style="display: none;"></div>
      </div>
    </div>
  </div>

  <div class="center-row">
    <div class="panel center-stack">
      
      <div id="standardStack" class="stack-row">
        <div>
          <div class="info">Draw pile</div>
          <div id="drawPile" class="card back small">DECK</div>
        </div>
        <div style="display:flex;flex-direction:column;align-items:center">
          <div class="info">Discard (top)</div>
          <div id="discardTop" class="card"></div>
        </div>
      </div>
      
      <div id="warStack" class="stack-row" style="display: none; flex-direction: column; align-items: center; width: 100%;">
        <div class="war-pot-container">
            <div class="war-pot-label" id="warPotLabel">Pot: 0 Cards</div>
            <div class="war-pot-visual" id="warPotVisual"></div>
        </div>
        
        <div class="war-battle-zone">
            <div class="war-slot">
                <div class="info">You</div>
                <div id="warCardP1" class="card"></div>
            </div>
            <div style="font-weight:800; color:var(--muted); font-size: 20px;">VS</div>
            <div class="war-slot">
                <div class="info">Opponent</div>
                <div id="warCardP2" class="card"></div>
            </div>
        </div>
        
        <div class="war-last-result" id="warLastResult"></div>
      </div>
      
      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="drawBtn" class="secondary">Draw</button>
        <button id="passBtn" class="secondary" style="display: none;">Pass/Skip</button>
        <button id="shuffleBtn" class="secondary">Shuffle Discard</button>
      </div>
    </div>

    <div class="panel area">
      <div class="hand" id="playerHand">
      </div>
    </div>
  </div>
  
</div>
</div>

<div id="settingsModal" class="modal-overlay">
  <div class="modal-panel">
    <h2>Game Settings</h2>
    <div class="settings-group" id="settingsPanel">
      <label class="secondary">Game Type
        <select id="gameVariantSelect" class="secondary">
          <option value="c8" selected>Crazy Eights</option>
          <option value="uno">UNO</option>
          <option value="war">War</option>
        </select>
      </label>
      
      <label class="secondary" id="gameModeContainer">Game Mode
        <select id="gameModeSelect" class="secondary">
          <option value="pvc">Player vs. CPU</option>
          <option value="pvp">Player vs. Player</option>
        </select>
      </label>

      <div id="c8UnoSettings">
          <label class="secondary">Initial Cards
            <select id="initialHandSizeSelect" class="secondary">
              <option value="7">7 Cards</option>
              <option value="8" selected>8 Cards (Classic C8)</option>
            </select>
          </label>
          <label class="secondary" id="reverseSkipLabel" style="display: none;">Reverse Card Skips Opponent <input type="checkbox" id="reverseSkipChk"></label>
          <label class="secondary" id="stackWD4Label" style="display: none;">Allow Stacking WD4 on D2 <input type="checkbox" id="stackWD4Chk"></label>
          <label class="secondary">Must Play If Able <input type="checkbox" id="mustPlayIfAbleChk"></label>
          <label class="secondary">Draw Until Playable <input type="checkbox" id="drawUntilPlayableChk"></label>
          <label class="secondary">Allow Pass <input type="checkbox" id="allowPassChk"></label>
      </div>
      
      <label class="secondary">First Turn Rule
        <select id="firstTurnRuleSelect" class="secondary">
          <option value="p1">Player 1 Goes First</option>
          <option value="p2">Player 2/CPU Goes First</option>
          <option value="random">Random</option>
          <option value="loser">Loser Goes First</option>
        </select>
      </label>
    </div>
    <div class="modal-footer">
      <span class="warning">Applying settings will start a new game.</span>
      <div class="control-group">
        <button id="cancelSettingsBtn" class="secondary">Cancel</button>
        <button id="applySettingsBtn">Apply & Restart</button>
      </div>
    </div>
  </div>
</div>

<div id="rulesModal" class="modal-overlay">
  <div class="modal-panel">
    <h2>Game Rules</h2>
    <div id="rulesContent">
      <div id="rulesC8">
        <h3>Crazy Eights</h3>
        <ul>
          <li><b>Objective:</b> Be the first player to empty your hand.</li>
          <li><b>Play:</b> Match the top card of the discard pile by either <b>Rank</b> or <b>Suit</b>.</li>
          <li><b>Eights (8):</b> Eights are wild. You can play an 8 on any card. After playing, you must choose a new suit for the next player to follow.</li>
          <li><b>Drawing:</b> If you cannot play a card, you must draw from the deck.</li>
        </ul>
      </div>
      <div id="rulesUNO" style="display: none;">
        <h3>UNO</h3>
        <ul>
          <li><b>Objective:</b> Be the first player to empty your hand.</li>
          <li><b>Play:</b> Match the top card of the discard pile by either <b>Number</b>, <b>Color</b>, or <b>Symbol</b>.</li>
          <li><b>Wild:</b> A "WILD" card is wild. You can play it on any card. After playing, you must choose a new color.</li>
          <li><b>Action Cards:</b> Standard UNO actions (Skip, Reverse, D2, WD4) apply.</li>
        </ul>
      </div>
      <div id="rulesWar" style="display: none;">
        <h3>War</h3>
        <ul>
            <li><b>Objective:</b> Collect all 52 cards in the deck.</li>
            <li><b>Play:</b> Click your deck to flip the top card. CPU flips too.</li>
            <li><b>Battle:</b> Higher rank wins both cards (A &gt; K &gt; Q ... &gt; 2).</li>
            <li><b>WAR (Tie):</b> If ranks are tied, it is WAR! You must click your deck again to add 3 cards <b>face up</b> to the pot, then flip one more card to battle. Winner takes all.</li>
            <li><b>Win:</b> The game ends when one player runs out of cards.</li>
        </ul>
      </div>
    </div>
    <div class="modal-footer">
      <button id="closeRulesBtn">Close</button>
    </div>
  </div>
</div>

<div id="logModal" class="modal-overlay">
  <div class="modal-panel">
    <h2>Full Game Log</h2>
    <div id="fullLog" class="log-full"></div>
    <div class="modal-footer">
      <button id="closeLogBtn">Close</button>
    </div>
  </div>
</div>

<div id="endGameModal" class="modal-overlay">
  <div class="modal-panel">
    <h2 id="endGameTitle">Game Over</h2>
    <p id="endGameMessage" style="font-size: 16px; text-align: center; margin: 20px 0;"></p>
    <div class="modal-footer" style="justify-content: center;">
      <button id="endGameNewGameBtn">Play Again</button>
    </div>
  </div>
</div>

<div id="warningModal" class="modal-overlay">
  <div class="modal-panel">
    <h2 id="warningTitle">Penalty Warning</h2>
    <p id="warningMessage" style="font-size: 16px; margin: 20px 0;"></p>
    <div class="modal-footer" style="justify-content: flex-end;">
      <button id="closeWarningBtn">Got it</button>
    </div>
  </div>
</div>

<div id="suitPickerModal" class="modal-overlay no-blur">
  <div class="modal-panel">
    <h2 id="suitPickerTitle">Choose a Suit</h2>
    <div id="suitPickerButtons">
    </div>
  </div>
</div>

<div id="handOverModal" class="modal-overlay">
  <div class="modal-panel">
    <h2>Pass the Device</h2>
    <p id="handOverMessage" style="font-size: 16px; text-align: center; margin: 20px 0;">Pass to Player 2. Click OK when ready.</p>
    <div class="modal-footer" style="justify-content: center;">
      <button id="handOverBtn">OK</button>
    </div>
  </div>
</div>


<script>
// Constants
const SUITS=['♠','♥','♦','♣'];
const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const UNO_COLORS=['R','G','B','Y'];
const UNO_SPECIAL=['SKIP','REV','D2','WILD','WD4'];
const SPEEDS = [ {label: 'Normal', delay: 700}, {label: 'Slow', delay: 2500}, {label: 'Instant', delay: 0} ];

// State
let state={
  deck:[], discard:[], 
  players:{p1:[],p2:[]},
  currentPlayer:'p1',
  currentSuit:null, 
  currentColor:null,
  cpuPlayDelay: 700,
  speedIndex: 0,
  initialHandSize: 8,
  gameMode: 'pvc',
  gameVariant: 'c8', // 'c8', 'uno', 'war'
  unoMode:false, // legacy flag kept for logic compatibility
  mustPlayIfAble:false, 
  drawUntilPlayable:false, 
  allowPass:false,
  reverseSkip: false,
  stackWD4onD2: false,
  firstTurnRule: 'p1',
  lastWinner: null,
  uiLocked: false,
  isPickingSuit: false,
  pendingDraw: 0,
  penaltyAttemptCount: 0,
  // War Specific
  warPot: [],
  warActive: {p1: null, p2: null},
  warState: 'idle', // 'idle', 'tie_pending_resolve', 'resolved'
};

const el={
  playerHand:document.getElementById('playerHand'),
  drawPile:document.getElementById('drawPile'),
  discardTop:document.getElementById('discardTop'),
  drawBtn:document.getElementById('drawBtn'),
  passBtn:document.getElementById('passBtn'),
  newGameBtn:document.getElementById('newGameBtn'),
  opponentCardCount:document.getElementById('opponentCardCount'),
  statusText:document.getElementById('statusText'),
  logPreview:document.getElementById('logPreview'),
  turnLabel:document.getElementById('turnLabel'),
  opponentInfo:document.getElementById('opponentInfo'),
  opponentLabel:document.getElementById('opponentLabel'),
  opponentHandLabel:document.getElementById('opponentHandLabel'),
  playerHandLabel:document.getElementById('playerHandLabel'), 
  currentSuit:document.getElementById('currentSuit'),
  hintBtn:document.getElementById('hintBtn'),
  cpuSpeedBtn:document.getElementById('cpuSpeedBtn'),
  shuffleBtn:document.getElementById('shuffleBtn'),
  settingsBtn: document.getElementById('settingsBtn'),
  settingsModal: document.getElementById('settingsModal'),
  applySettingsBtn: document.getElementById('applySettingsBtn'),
  cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
  rulesBtn: document.getElementById('rulesBtn'),
  rulesModal: document.getElementById('rulesModal'),
  closeRulesBtn: document.getElementById('closeRulesBtn'),
  rulesC8: document.getElementById('rulesC8'),
  rulesUNO: document.getElementById('rulesUNO'),
  rulesWar: document.getElementById('rulesWar'),
  logModal: document.getElementById('logModal'),
  fullLog: document.getElementById('fullLog'),
  closeLogBtn: document.getElementById('closeLogBtn'),
  endGameModal: document.getElementById('endGameModal'),
  endGameTitle: document.getElementById('endGameTitle'),
  endGameMessage: document.getElementById('endGameMessage'),
  endGameNewGameBtn: document.getElementById('endGameNewGameBtn'),
  // Warning Modal
  warningModal: document.getElementById('warningModal'),
  warningTitle: document.getElementById('warningTitle'),
  warningMessage: document.getElementById('warningMessage'),
  closeWarningBtn: document.getElementById('closeWarningBtn'),
  
  suitPickerModal: document.getElementById('suitPickerModal'),
  suitPickerTitle: document.getElementById('suitPickerTitle'),
  suitPickerButtons: document.getElementById('suitPickerButtons'),
  handOverModal: document.getElementById('handOverModal'),
  handOverMessage: document.getElementById('handOverMessage'),
  handOverBtn: document.getElementById('handOverBtn'),
  gameModeSelect: document.getElementById('gameModeSelect'),
  gameVariantSelect: document.getElementById('gameVariantSelect'),
  gameModeContainer: document.getElementById('gameModeContainer'),
  c8UnoSettings: document.getElementById('c8UnoSettings'),
  initialHandSizeSelect: document.getElementById('initialHandSizeSelect'),
  unoModeChk:document.getElementById('unoModeChk'),
  reverseSkipLabel: document.getElementById('reverseSkipLabel'),
  reverseSkipChk: document.getElementById('reverseSkipChk'),
  stackWD4Label: document.getElementById('stackWD4Label'),
  stackWD4Chk: document.getElementById('stackWD4Chk'),
  mustPlayIfAbleChk:document.getElementById('mustPlayIfAbleChk'),
  drawUntilPlayableChk:document.getElementById('drawUntilPlayableChk'),
  allowPassChk:document.getElementById('allowPassChk'),
  firstTurnRuleSelect: document.getElementById('firstTurnRuleSelect'),
  // War Elements
  standardStack: document.getElementById('standardStack'),
  warStack: document.getElementById('warStack'),
  warCardP1: document.getElementById('warCardP1'),
  warCardP2: document.getElementById('warCardP2'),
  warPotLabel: document.getElementById('warPotLabel'),
  warPotVisual: document.getElementById('warPotVisual'),
  warLastResult: document.getElementById('warLastResult'),
  
  // Mobile toggles elements
  statusToggle: document.getElementById('statusToggle'),
  logToggle: document.getElementById('logToggle'),
  statusContent: document.getElementById('statusContent'),
  logContent: document.getElementById('logContent'),
  statusChevron: document.getElementById('statusChevron'),
  logChevron: document.getElementById('logChevron'),
  currentSuitPreview: document.getElementById('currentSuitPreview'),
  fullLogContent: document.getElementById('fullLogContent')
};

function logMsg(txt){
  const p = document.createElement('div');
  p.textContent = txt;
  el.fullLogContent.prepend(p.cloneNode(true)); 
  el.fullLog.prepend(p); 
  
  if (window.innerWidth > 980) {
    el.logPreview.prepend(p.cloneNode(true));
    while(el.logPreview.children.length > 4) {
      el.logPreview.lastChild.remove();
    }
  }
}

function shuffle(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;}
function cardLabel(c){if (!c) return '??'; return c.rank==='WD4' ? 'Wild Draw 4' : c.rank+(c.suit||c.color||'');}

// Rank value helper for War
function getWarValue(rank) {
    if (rank === 'A') return 14;
    if (rank === 'K') return 13;
    if (rank === 'Q') return 12;
    if (rank === 'J') return 11;
    return parseInt(rank);
}

function makeDeck(){
  if(state.gameVariant === 'uno'){
    let deck=[];
    for(const color of UNO_COLORS){
      deck.push({rank:'0',color:color,id:`${color}0`});
      for(let i=1;i<=9;i++){deck.push({rank:i,color:color,id:`${color}${i}a`});deck.push({rank:i,color:color,id:`${color}${i}b`});}
      for(const s of ['SKIP','REV','D2']) deck.push({rank:s,color:color,id:`${color}${s}1`}),deck.push({rank:s,color:color,id:`${color}${s}2`}); 
    }
    for(let i=0;i<4;i++) deck.push({rank:'WILD',color:null,id:`W${i}`});
    for(let i=0;i<4;i++) deck.push({rank:'WD4',color:null,id:`WD4${i}`});
    return shuffle(deck);
  } else {
    // Standard Deck (C8 and War)
    let deck=[]; for(const s of SUITS) for(const r of RANKS) deck.push({rank:r,suit:s,id:`${r}${s}`}); return shuffle(deck);
  }
}

function renderAll(){
  const isWar = state.gameVariant === 'war';
  let p1 = state.players.p1;
  let p2 = state.players.p2;
  let p1sTurn = state.currentPlayer === 'p1';
  
  // NEW: Toggle war-mode class on center-row for styling hooks
  const centerRow = document.querySelector('.center-row');
  
  if(isWar) {
      // Toggle class for CSS
      centerRow.classList.add('war-mode');

      // WAR UI Update
      el.standardStack.style.display = 'none';
      el.warStack.style.display = 'flex';
      el.playerHand.innerHTML = ''; // Clear individual cards
      
      // Render P1 "Deck" as a big clickable button in hand area
      const deckBtn = document.createElement('div');
      deckBtn.className = 'card back war-deck-btn';
      deckBtn.style.width = '100px';
      deckBtn.style.height = '140px';
      deckBtn.style.margin = '0 auto';
      deckBtn.style.cursor = 'pointer';
      deckBtn.innerHTML = `<div>YOU<br>${p1.length}</div>`;
      
      // Only allow click if it's P1's turn (manual trigger) and UI isn't strictly locked (though War logic handles its own locking)
      deckBtn.onclick = () => { if(!state.uiLocked) playWarTurn(); };
      
      if(state.uiLocked) deckBtn.style.opacity = 0.6;
      el.playerHand.appendChild(deckBtn);
      
      // Update Center Arena
      renderCardToDiv(el.warCardP1, state.warActive.p1);
      renderCardToDiv(el.warCardP2, state.warActive.p2);
      
      el.warPotLabel.textContent = `Pot: ${state.warPot.length} Cards`;
      
      // Visualize Pot
      el.warPotVisual.innerHTML = '';
      state.warPot.forEach(c => {
        const mc = document.createElement('div');
        mc.className = 'war-mini-card';
        mc.innerHTML = `<div>${c.rank}</div><div>${c.suit}</div>`;
        if(c.suit) mc.dataset.suit = c.suit;
        el.warPotVisual.appendChild(mc);
      });
      
      el.opponentCardCount.textContent = p2.length;
      el.turnLabel.textContent = "Turn: You (Click Deck)";
      el.opponentHandLabel.textContent = "P2 Deck";
      el.currentSuit.textContent = "Mode: War";
      
      // Hide standard controls
      el.drawBtn.style.display = 'none';
      el.passBtn.style.display = 'none';
      el.shuffleBtn.style.display = 'none';
      el.hintBtn.style.display = 'none'; // Hide hint in War

  } else {
      // Remove class
      centerRow.classList.remove('war-mode');

      // Standard C8/UNO UI
      el.standardStack.style.display = 'flex';
      el.warStack.style.display = 'none';
      el.hintBtn.style.display = 'inline-block';
      
      if (el.playerCount) {
        el.playerCount.textContent = p1sTurn ? p1.length : p2.length;
      }
      
      if (p1sTurn) {
          el.opponentCardCount.textContent = p2.length;
          el.turnLabel.textContent = "Turn: You";
      } else {
          el.opponentCardCount.textContent = p2.length; 
          el.turnLabel.textContent = "Turn: CPU";
      }

      renderDiscard();
      el.drawPile.textContent = state.deck.length > 0 ? state.deck.length : '0';
      const label = state.gameVariant === 'uno' ? "Color" : "Suit";
      const activeSuitColor = state.currentSuit || state.currentColor || '—';
      el.currentSuit.textContent = `${label}: ${activeSuitColor}`;
      el.currentSuitPreview.textContent = activeSuitColor;
      
      el.passBtn.style.display = state.allowPass ? 'inline-block' : 'none';
      el.drawBtn.style.display = 'inline-block';
      el.shuffleBtn.style.display = 'inline-block';
  }
  
  el.cpuSpeedBtn.style.display = state.gameMode === 'pvc' ? 'inline-block' : 'none';
}

function renderCardToDiv(div, card) {
    div.className = 'card';
    div.innerHTML = '';
    div.removeAttribute('data-suit');
    div.removeAttribute('data-color');
    div.classList.remove('back', 'uno', 'wild', 'small');
    
    if (!card) {
        div.style.border = '2px dashed var(--muted)';
        div.style.background = 'transparent';
        div.style.boxShadow = 'none';
        return;
    }
    
    div.style.border = '';
    div.style.background = '';
    div.style.boxShadow = '';
    
    div.innerHTML = `<div class="rank">${card.rank}</div><div class="suit">${card.suit}</div>`;
    if(card.suit) div.dataset.suit = card.suit;
}


function renderHand(container,cards,isHuman){
  if(state.gameVariant === 'war') return; // War handles hand differently

  container.innerHTML='';
  const isHandLocked = state.uiLocked && !state.isPickingSuit; 
  container.style.opacity = (isHuman && isHandLocked) ? 0.6 : 1;
  container.style.pointerEvents = (isHuman && isHandLocked) ? 'none' : 'auto';
  
  container.classList.remove('size-m', 'size-l', 'size-xl');
  if (isHuman && window.innerWidth <= 980) {
     container.classList.add('size-xl'); 
  } else {
    if (cards.length > 28) { container.classList.add('size-xl'); }
    else if (cards.length > 20) { container.classList.add('size-l'); }
    else if (cards.length > 16) { container.classList.add('size-m'); } 
  }

  cards.forEach((c,i)=>{
    const d=document.createElement('div');
    d.className = 'card';
    d.title=cardLabel(c);
    
    if(state.gameVariant === 'uno') {
      d.classList.add('uno');
      
      if (c.rank === 'WILD' || c.rank === 'WD4') {
          d.classList.add('wild');
          const rankDisplay = c.rank === 'WD4' ? '+4' : 'W';
          d.innerHTML = `<div class="corner-tl">${rankDisplay}</div><div class="corner-br">${rankDisplay}</div>`;
      } else {
          d.innerHTML = `<div class="rank">${c.rank}</div>`;
      }
      
      if(c.color) {
        d.dataset.color = c.color;
      }
    } else {
      d.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;
      if(c.suit) d.dataset.suit = c.suit;
    }
    
    d.addEventListener('click',()=>attemptPlayCard(state.currentPlayer,i));
    container.appendChild(d);
  });
}

function renderDiscard(){
  el.discardTop.innerHTML='';
  const top=state.discard[state.discard.length-1];
  
  if(top){
    el.discardTop.className = 'card';
    el.discardTop.title = cardLabel(top);
    
    if(state.gameVariant === 'uno') {
      el.discardTop.classList.add('uno');
      
      if (top.rank === 'WILD' || top.rank === 'WD4') {
          el.discardTop.classList.add('wild');
          const rankDisplay = top.rank === 'WD4' ? '+4' : 'W';
          el.discardTop.innerHTML = `<div class="corner-tl">${rankDisplay}</div><div class="corner-br">${rankDisplay}</div>`;
      } else {
          el.discardTop.innerHTML = `<div class="rank">${top.rank}</div>`;
      }

      if(top.color) {
        el.discardTop.dataset.color = top.color;
      }
      delete el.discardTop.dataset.suit;
    } else {
      el.discardTop.innerHTML = `<div class="rank">${top.rank}</div><div class="suit">${top.suit}</div>`;
      if(top.suit) el.discardTop.dataset.suit = top.suit;
      delete el.discardTop.dataset.color;
      el.discardTop.classList.remove('uno', 'wild');
    }

    if (top.rank === '8' || top.rank === 'WILD' || top.rank === 'WD4') {
      const activeSuit = state.currentSuit; 
      if (activeSuit) {
        const overlay = document.createElement('div');
        overlay.className = 'wild-suit-indicator';
        overlay.textContent = state.gameVariant === 'uno' ? activeSuit : activeSuit;
        if (state.gameVariant === 'uno') {
          overlay.dataset.color = activeSuit;
        } else {
          overlay.dataset.suit = activeSuit;
        }
        el.discardTop.appendChild(overlay);
      }
    }
  }
  else {
    el.discardTop.innerHTML = '—';
    el.discardTop.className = 'card';
  }
}

// --- WAR LOGIC START ---
function playWarTurn() {
    if(state.gameVariant !== 'war') return;
    
    // Logic path depends on State
    if (state.warState === 'tie_pending_resolve') {
        resolveWarTie();
        return;
    }

    // Normal Battle: Both flip top card
    const c1 = state.players.p1.shift();
    const c2 = state.players.p2.shift();
    
    // Immediate game over check (rare edge case here, usually caught after resolution)
    if (!c1 || !c2) {
        if(!c1 && c2) { state.players.p2.push(c2); checkWin(); return; }
        if(c1 && !c2) { state.players.p1.push(c1); checkWin(); return; }
        checkWin(); return;
    }

    state.warActive = {p1: c1, p2: c2};
    state.warPot.push(c1, c2);
    
    renderAll();
    
    const v1 = getWarValue(c1.rank);
    const v2 = getWarValue(c2.rank);
    
    if (v1 > v2) {
        // Win
        const winMsg = `You won ${state.warPot.length} cards (${c1.rank} > ${c2.rank}).`;
        el.warLastResult.textContent = winMsg;
        logMsg(winMsg);
        state.uiLocked = true; // Pause for effect
        
        setTimeout(() => {
             state.players.p1.push(...state.warPot);
             resetWarRound();
        }, state.cpuPlayDelay || 500);
        
    } else if (v2 > v1) {
        // Loss
        const loseMsg = `CPU won ${state.warPot.length} cards (${c2.rank} > ${c1.rank}).`;
        el.warLastResult.textContent = loseMsg;
        logMsg(loseMsg);
        state.uiLocked = true; 
        
        setTimeout(() => {
             state.players.p2.push(...state.warPot);
             resetWarRound();
        }, state.cpuPlayDelay || 500);
        
    } else {
        // Tie
        const tieMsg = `TIE (${c1.rank} vs ${c2.rank})! Click deck to Draw 3 & Battle.`;
        el.warLastResult.textContent = "WAR! (Tie)";
        updateStatus(tieMsg);
        logMsg("WAR triggered! Waiting for player to click deck...");
        state.warState = 'tie_pending_resolve';
        // Don't reset pot or active cards yet.
        // UI remains unlocked so user can click again.
    }
}

function resolveWarTie() {
    // User clicked deck during 'tie_pending_resolve'
    // Logic: Add up to 3 cards to pot FACE UP, then flip 1 (need at least 2 total cards to survive, ideally 4)
    // If < 4 cards, we use all but the last one for the pot, and the last one battles.
    
    if(state.players.p1.length === 0) { checkWin(); return; }
    if(state.players.p2.length === 0) { checkWin(); return; }

    // Move cards to pot (exposed)
    // Max 3, but leave 1 for the battle
    let p1PotCount = Math.min(3, state.players.p1.length - 1);
    let p2PotCount = Math.min(3, state.players.p2.length - 1);
    
    // If a player has exactly 1 card left (length=1), potCount becomes 0. They just battle.
    if (p1PotCount < 0) p1PotCount = 0; 
    if (p2PotCount < 0) p2PotCount = 0;

    for(let i=0; i<p1PotCount; i++) state.warPot.push(state.players.p1.shift());
    for(let i=0; i<p2PotCount; i++) state.warPot.push(state.players.p2.shift());
    
    logMsg(`Added exposed cards to pot. Pot size: ${state.warPot.length}`);
    
    state.warState = 'idle'; // Reset state so playWarTurn runs normal comparison
    playWarTurn(); // Immediately flip next card for battle
}

function resetWarRound() {
    state.warPot = [];
    state.warActive = {p1: null, p2: null};
    state.warState = 'idle';
    state.uiLocked = false;
    if(!checkWin()) {
        renderAll();
        updateStatus("Click deck to play next turn.");
    }
}
// --- WAR LOGIC END ---


function legalPlay(c){
  if(state.gameVariant === 'war') return false; // No choosing cards in War

  if (state.pendingDraw > 0 && state.gameVariant === 'uno') {
    const top = state.discard[state.discard.length-1];
    const topRank = top.rank;
    if (c.rank === 'D2' && topRank === 'D2') return true;
    if (state.stackWD4onD2 && c.rank === 'WD4' && topRank === 'D2') return true;
    return false; 
  }
  
  const top=state.discard[state.discard.length-1];
  if(!top) return true;
  if(state.gameVariant === 'uno'){
    if(c.rank==='WILD' || c.rank==='WD4') return true;
    if(state.currentColor && c.color === state.currentColor) return true;
    if(c.rank===top.rank) return true;
    return false;
  } else {
    return c.suit===state.currentSuit||c.rank===top.rank||c.rank==='8';
  }
}

function isWildCard(c) {
    if (state.gameVariant === 'uno') return c.rank === 'WILD' || c.rank === 'WD4';
    return c.rank === '8';
}

function applySpecial(card,player){
  let skipNext = false;
  if(state.gameVariant !== 'uno') return skipNext;
  
  const nextPlayer = (player === 'p1') ? 'p2' : 'p1';
  const nextPlayerName = (state.gameMode === 'pvc' && nextPlayer === 'p2') ? 'CPU' : `Player ${nextPlayer.substring(1)}`;

  if(card.rank==='SKIP'){
    logMsg(`${nextPlayerName} is skipped!`);
    skipNext = true;
  }
  
  if(card.rank==='REV'){
    if(state.reverseSkip) {
      logMsg(`Reverse played! ${nextPlayerName} is skipped!`);
      skipNext = true;
    } else {
      logMsg(`Reverse played! Turn passes normally.`);
      skipNext = false;
    }
  }

  if(card.rank==='D2'){
    logMsg(`Draw 2 played! ${nextPlayerName} faces penalty.`);
    state.pendingDraw += 2;
    skipNext = false;
  }
  
  if(card.rank==='WD4'){
    logMsg(`Wild Draw 4 played! ${nextPlayerName} faces penalty.`);
    state.pendingDraw += 4;
    skipNext = false;
  }
  
  return skipNext;
}

function resolvePenaltyDraw(player) {
  const drawAmount = state.pendingDraw;
  state.pendingDraw = 0; 
  state.penaltyAttemptCount = 0; 
  
  const playerName = (player === 'p1') ? 'Player 1' : (state.gameMode === 'pvc' ? 'CPU' : 'Player 2');
  logMsg(`Penalty: ${playerName} must draw ${drawAmount} cards.`);
  updateStatus(`${playerName} drawing ${drawAmount} penalty cards...`);

  state.uiLocked = true; 
  
  for (let i = 0; i < drawAmount; i++) {
    drawCardForPlayer(player);
  }
  
  renderAll(); 
  if (player === 'p1' || state.gameMode === 'pvp') { 
    renderHand(el.playerHand, state.players[player], true);
  }
  
  setTimeout(() => {
    logMsg(`${playerName} drew ${drawAmount} cards. Turn ends.`);
    updateStatus(`Turn passes.`);
    
    if (player === 'p1') {
      if (state.gameMode === 'pvc') passTurnToCPU();
      else passTurnToP2();
    } else { 
      if (state.gameMode === 'pvc') passTurnToP1_Human();
      else passTurnToP1();
    }
  }, state.cpuPlayDelay / 2);
}

function passTurnToP1_Human() {
  state.currentPlayer = 'p1';
  state.penaltyAttemptCount = 0;
  el.opponentInfo.textContent = "waiting";
  updateStatus("Your turn.");
  state.uiLocked = false;
  renderAll();
  renderHand(el.playerHand, state.players.p1, true);
}

function passTurnToCPU() {
  state.currentPlayer = 'p2';
  state.penaltyAttemptCount = 0;
  state.uiLocked = true;
  el.opponentInfo.textContent = "thinking...";
  updateStatus("CPU thinking...");
  renderAll();
  setTimeout(cpuTurn, state.cpuPlayDelay);
}

function showP1Hand(isFirstTurn = false) {
  el.handOverModal.classList.remove('visible');
  state.currentPlayer = 'p1';
  state.penaltyAttemptCount = 0;
  
  updateStatus("Player 1's turn.");
  state.uiLocked = false;
  renderAll();
  renderHand(el.playerHand, state.players.p1, true);
  if(isFirstTurn) logMsg("Game started. Player 1's turn.");
}

function showP2Hand(isFirstTurn = false) {
  el.handOverModal.classList.remove('visible');
  state.currentPlayer = 'p2';
  state.penaltyAttemptCount = 0;
  state.uiLocked = false; 
  
  updateStatus("Player 2's turn.");
  renderAll();
  renderHand(el.playerHand, state.players.p2, true);
  if(isFirstTurn) logMsg("Game started. Player 2's turn.");
}

function passTurnToP1() {
  state.uiLocked = true;
  el.playerHand.style.opacity = 0;
  el.handOverMessage.textContent = "Pass to Player 1. Click OK when ready."
  el.handOverModal.classList.add('visible');
  el.handOverBtn.onclick = showP1Hand;
}

function passTurnToP2() {
  state.uiLocked = true;
  el.playerHand.style.opacity = 0;
  el.handOverMessage.textContent = "Pass to Player 2. Click OK when ready."
  el.handOverModal.classList.add('visible');
  el.handOverBtn.onclick = showP2Hand;
}


// --- CPU Logic ---

function cpuTurn(){
  if(state.gameMode !== 'pvc' || state.currentPlayer !== 'p2') return;
  if(state.gameVariant === 'war') return; // War is manual click driven

  logMsg('--- CPU TURN START ---'); 
  el.opponentInfo.textContent = "thinking...";
  const hand=state.players.p2;

  if (state.pendingDraw > 0 && state.gameVariant === 'uno') {
    logMsg(`CPU has a pending draw of ${state.pendingDraw}.`);
    const top = state.discard[state.discard.length-1];
    
    let stackCardIndex = -1;
    if (top.rank === 'D2') {
        stackCardIndex = hand.findIndex(c => c.rank === 'D2');
        if (stackCardIndex === -1 && state.stackWD4onD2) {
           stackCardIndex = hand.findIndex(c => c.rank === 'WD4');
        }
    }

    if (stackCardIndex !== -1) {
        logMsg('CPU will stack attack.');
        cpuPlayCard(stackCardIndex); 
        return;
    } else {
        logMsg('CPU cannot stack, must draw penalty.');
        resolvePenaltyDraw('p2'); 
        return;
    }
  }
  
  let cardToPlay = null;
  let cardIndex = -1;
  
  for(let i=0; i<hand.length; i++){
    const c = hand[i];
    if(legalPlay(c) && !isWildCard(c)) {
        cardToPlay = c;
        cardIndex = i;
        break;
    }
  }
  
  if(!cardToPlay) {
      for(let i=0; i<hand.length; i++){
        const c = hand[i];
        if(legalPlay(c) && isWildCard(c)){
            cardToPlay = c;
            cardIndex = i;
            break;
        }
      }
  }

  if(cardToPlay){
    logMsg('CPU found playable card: ' + cardLabel(cardToPlay));
    cpuPlayCard(cardIndex);
    return;
  }

  logMsg(`CPU found NO playable cards. Current target: ${state.currentSuit || state.currentColor}.`);

  if(state.drawUntilPlayable) {
    logMsg('CPU beginning draw-until-playable loop.');
    cpuDrawLoop(); 
    return;
  } else {
    logMsg('CPU drawing one card.');
    const drawn = drawCardForPlayer('p2');
    if (drawn) {
        logMsg('CPU drew and passes turn.');
    } else {
        logMsg('CPU failed to draw and passes turn.');
    }
    passTurnToP1_Human();
    return;
  }
}

function cpuPlayCard(idx) {
  const cardPlayed = state.players.p2.splice(idx, 1)[0];
  state.discard.push(cardPlayed);
  logMsg(`CPU played ${cardLabel(cardPlayed)}`);
  
  if(isWildCard(cardPlayed)){
    state.currentSuit=chooseSuit('p2',cardPlayed);
    state.currentColor=state.gameVariant === 'uno' ? state.currentSuit : null;
    logMsg(`CPU changed color/suit to ${state.currentSuit}`);
  } else{
    state.currentSuit=cardPlayed.suit||cardPlayed.color;
    state.currentColor=cardPlayed.color; 
  }

  const skipTurn = applySpecial(cardPlayed, 'p2');
  if(checkWin()) return;
  
  if(skipTurn) {
    logMsg('CPU skipped Player 1 and plays again.');
    updateStatus("CPU skipped your turn. CPU playing again...");
    el.opponentInfo.textContent = "playing again";
    renderAll();
    setTimeout(cpuTurn, state.cpuPlayDelay);
  } else {
    passTurnToP1_Human();
  }
}

function cpuDrawLoop() {
  if (state.gameMode !== 'pvc' || state.currentPlayer !== 'p2') return; 

  const drawnCard = drawCardForPlayer('p2');
  
  if (!drawnCard) {
    logMsg("CPU cannot draw and must pass.");
    passTurnToP1_Human();
    return;
  }

  if (legalPlay(drawnCard)) {
    logMsg('CPU auto-playing drawn card.');
    const idx = state.players.p2.lastIndexOf(drawnCard);
    cpuPlayCard(idx); 
  } else {
    logMsg('CPU draws again...');
    setTimeout(cpuDrawLoop, state.cpuPlayDelay); 
  }
}


function chooseSuit(playerType,card){
  const hand=state.players[playerType];
  if(state.gameVariant === 'uno'){
    let counts={R:0,G:0,B:0,Y:0};
    hand.forEach(c=>{if(c.color) counts[c.color]++;});
    return Object.keys(counts).reduce((a,b)=>counts[a]>counts[b]?a:b, UNO_COLORS[0]);
  } else{
    let counts={'♠':0,'♥':0,'♦':0,'♣':0};
    hand.forEach(c=>{if(c.suit) counts[c.suit]++;});
    return Object.keys(counts).reduce((a,b)=>counts[a]>counts[b]?a:b, SUITS[0]);
  }
}

function drawCardForPlayer(player) {
  if(state.deck.length === 0) {
    logMsg("Deck is empty. Attempting to shuffle discard pile...");
    if(state.discard.length <= 1) {
      logMsg("No cards in discard to shuffle. Cannot draw.");
      return false;
    }
    el.shuffleBtn.click();
    logMsg('Shuffling takes a moment...');
  }

  if(state.deck.length === 0) {
     logMsg("Deck is still empty after shuffle attempt. Cannot draw.");
     return false;
  }

  const c = state.deck.shift();
  state.players[player].push(c);
  
  return c;
}

function playerDraw() {
  if (state.pendingDraw > 0 && state.gameVariant === 'uno') {
    // Player is accepting the penalty.
    resolvePenaltyDraw(state.currentPlayer); 
    return 'resolved_penalty'; 
  }

  const drawnCard = drawCardForPlayer(state.currentPlayer);

  if (!drawnCard) {
    return 'draw_failed'; 
  }
  
  const playerName = state.currentPlayer === 'p1' ? 'Player 1' : 'Player 2';
  logMsg(`${playerName} drew ${cardLabel(drawnCard)}.`);

  if(state.drawUntilPlayable) {
    if (legalPlay(drawnCard)) {
      updateStatus(`You drew ${cardLabel(drawnCard)}. You can play it, draw again, or pass.`);
    } else {
      updateStatus(`You drew ${cardLabel(drawnCard)}. Not playable. Draw again or pass.`);
    }
    return 'can_draw_again'; 
  }
  
  return 'drew_and_pass'; 
}

function attemptPlayCard(player,idx){
  if(state.gameVariant === 'war') return; // Disabled in War
  if(state.currentPlayer!==player){updateStatus("Not your turn");return;}
  if(state.uiLocked) return;
  
  const hand=state.players[player];const card=hand[idx];
  
  if(!legalPlay(card)){
    if (state.pendingDraw > 0) {
      state.penaltyAttemptCount++;
      if (state.penaltyAttemptCount >= 2) {
          showPenaltyWarning();
          return;
      }
      updateStatus(`You have a ${state.pendingDraw}-card penalty. You must play a stacking card or Draw.`);
    } else {
      updateStatus("Illegal play");
    }
    return;
  }
  
  state.penaltyAttemptCount = 0;
  
  hand.splice(idx,1);state.discard.push(card);
  const playerName = (player === 'p1') ? 'Player 1' : (state.gameMode === 'pvc' ? 'CPU' : 'Player 2');
  logMsg(`${playerName} played ${cardLabel(card)}`);
  
  renderAll(); 
  if (player === 'p1' || (state.gameMode === 'pvp' && player === state.currentPlayer)) {
      renderHand(el.playerHand, hand, true);
  }
  
  if(checkWin()) return;
  
  let skipTurn = false;
  
  if(isWildCard(card)){
    updateStatus("Choose a suit/color.");
    state.uiLocked = true;
    state.isPickingSuit = true;
    showSuitPickerModal(card); 
    return;
  }
  else{
    state.currentSuit=card.suit||card.color;
    state.currentColor=card.color; 
    skipTurn = applySpecial(card, player);

    if (state.gameVariant === 'uno' && card.rank === 'SKIP') {
        skipTurn = true; 
    }
  }

  if(player==='p1'){
      if(skipTurn){
          updateStatus("You skipped the opponent. Play again.");
          state.uiLocked = false;
          renderAll();
          renderHand(el.playerHand, state.players.p1, true);
      } else {
          if (state.gameMode === 'pvc') passTurnToCPU();
          else passTurnToP2();
      }
  } else {
      if(skipTurn){
          updateStatus("You skipped Player 1. Play again.");
          state.uiLocked = false;
          renderAll();
          renderHand(el.playerHand, state.players.p2, true);
      } else {
          passTurnToP1();
      }
  }
}

function showPenaltyWarning() {
    const top = state.discard[state.discard.length - 1];
    let msg = `You are facing a +${state.pendingDraw} card penalty!`;
    let sub = "";

    if (top.rank === 'WD4') {
        sub = "You cannot stack on a Wild Draw 4. You must click the DRAW pile to accept the penalty.";
    } else if (top.rank === 'D2') {
         let options = ["Draw 2"];
         if (state.stackWD4onD2) options.push("Wild Draw 4");
         sub = `To avoid drawing, you must stack a ${options.join(" or ")}. Otherwise, click the DRAW pile to accept penalty.`;
    }

    el.warningTitle.textContent = "Penalty Action Required";
    el.warningMessage.textContent = msg + " " + sub;
    el.warningModal.classList.add('visible');
}

function showSuitPickerModal(card=null){
  const modal = el.suitPickerModal;
  const title = el.suitPickerTitle;
  const buttonContainer = el.suitPickerButtons;
  const player = state.currentPlayer;
  
  buttonContainer.innerHTML = '';
  
  let choices = [];
  if(state.gameVariant === 'uno') {
    title.textContent = 'Choose a color:';
    choices = [
      { suit: 'R', text: 'Red' },
      { suit: 'G', text: 'Green' },
      { suit: 'B', text: 'Blue' },
      { suit: 'Y', text: 'Yellow' }
    ];
  } else {
    title.textContent = 'Choose a suit:';
    choices = [
      { suit: '♠', text: '♠ Spades' },
      { suit: '♥', text: '♥ Hearts' },
      { suit: '♦', text: '♦ Diamonds' },
      { suit: '♣', text: '♣ Clubs' }
    ];
  }
  
  choices.forEach(choice => {
    const b = document.createElement('button');
    b.className = 'suit-btn';
    b.dataset.suit = choice.suit;
    b.innerHTML = choice.text;
    
    if(state.gameVariant === 'uno') b.dataset.color = choice.suit;
    else if(choice.suit === '♥' || choice.suit === '♦') b.dataset.suit = choice.suit;

    b.onclick = () => {
      state.currentSuit = b.dataset.suit;
      state.currentColor = state.gameVariant === 'uno' ? b.dataset.suit : null;
      
      const skipTurn = applySpecial(card, player);
      
      const playerName = (player === 'p1') ? 'Player 1' : 'Player 2';
      logMsg(`${playerName} changed ${state.gameVariant === 'uno' ? 'color' : 'suit'} to ${state.currentSuit}`);
      
      modal.classList.remove('visible'); 
      state.isPickingSuit = false;
      
      renderAll(); 
      
      if(checkWin()) return;

      if(player==='p1'){
          if(skipTurn){
              updateStatus("You skipped the opponent. Play again.");
              state.uiLocked = false;
              renderAll();
              renderHand(el.playerHand, state.players.p1, true);
          } else {
              if (state.gameMode === 'pvc') passTurnToCPU();
              else passTurnToP2();
          }
      } else {
          if(skipTurn){
              updateStatus("You skipped Player 1. Play again.");
              state.uiLocked = false;
              renderAll();
              renderHand(el.playerHand, state.players.p2, true);
          } else {
              passTurnToP1();
          }
      }
    };
    buttonContainer.appendChild(b);
  });
    
  modal.classList.add('visible'); 
}

function checkWin(){
  let winner = null;
  if(state.players.p1.length===0) winner = 'p1';
  else if(state.players.p2.length===0) winner = 'p2';
  
  if(winner){
    state.uiLocked = true;
    renderAll();
    
    const p1Name = "Player 1";
    const p2Name = state.gameMode === 'pvc' ? "CPU" : "Player 2";
    const winnerName = winner === 'p1' ? p1Name : p2Name;
    const loserName = winner === 'p1' ? p2Name : p1Name;

    const msg = winnerName === 'Player 1' 
      ? `You (${p1Name}) win! 🎉` 
      : `${winnerName} wins. Better luck next time, ${loserName}.`;
    
    const title = winnerName === 'p1' ? "Congratulations!" : "Game Over";

    updateStatus(msg);
    logMsg(msg);
    state.lastWinner = winner;

    el.endGameTitle.textContent = title;
    el.endGameMessage.textContent = msg;
    el.endGameModal.classList.add('visible');
    
    return true;
  }
  return false;
}

function updateStatus(txt){el.statusText.textContent=txt;}

// --- NEW: Toggle Functions ---
function toggleLog() {
    const isCollapsed = el.logContent.classList.toggle('collapsed');
    el.logChevron.textContent = isCollapsed ? '▼' : '▲';
    
    if (window.innerWidth <= 980) {
      el.fullLogContent.style.display = isCollapsed ? 'none' : 'block';
    }
}

function toggleStatus() {
    const isCollapsed = el.statusContent.classList.toggle('collapsed');
    el.statusChevron.textContent = isCollapsed ? '▼' : '▲';
    
    if (window.innerWidth <= 980) {
      el.statusContent.style.display = isCollapsed ? 'none' : 'block';
    }
}

// --- Event Listeners ---

el.newGameBtn.addEventListener('click',()=>startGame());
el.drawBtn.addEventListener('click',()=>{
  if(state.currentPlayer!=='p1' && state.gameMode === 'pvc'){updateStatus("Not your turn");return;}
  if(state.uiLocked) return;

  if(state.mustPlayIfAble) {
    if(state.pendingDraw > 0) {
      const hasD2 = state.players[state.currentPlayer].some(c => c.rank === 'D2');
      let hasStackable = hasD2;
      if (state.stackWD4onD2 && !hasStackable) {
          const top = state.discard[state.discard.length-1];
          if (top.rank === 'D2') {
              hasStackable = state.players[state.currentPlayer].some(c => c.rank === 'WD4');
          }
      }
      
      if(hasStackable) {
        updateStatus("'Must Play If Able' is ON. You must stack or accept penalty.");
        return;
      }
    } else {
      const hasPlayableCard = state.players[state.currentPlayer].some(c => legalPlay(c));
      if(hasPlayableCard) {
        updateStatus("'Must Play If Able' is ON. You have a playable card and cannot draw.");
        return;
      }
    }
  }
  
  const drawResult = playerDraw(); 
  
  if (drawResult === 'resolved_penalty') {
      return;
  }
  
  const handToRender = state.players[state.currentPlayer];
  
  renderAll();
  renderHand(el.playerHand, handToRender, true);
  
  switch(drawResult) {
    case 'can_draw_again':
      break;
    case 'drew_and_pass':
      if (state.gameMode === 'pvc') {
        passTurnToCPU();
      } else {
        if (state.currentPlayer === 'p1') passTurnToP2();
        else passTurnToP1();
      }
      break;
    case 'draw_failed':
      break;
  }
});

el.passBtn.addEventListener('click',()=>{
  if(state.currentPlayer!=='p1' && state.gameMode === 'pvc'){updateStatus("Not your turn");return;}
  if(state.uiLocked) return;
  if(!state.allowPass){updateStatus("Passing is disabled by game settings.");return;}
  
  if(state.pendingDraw > 0) {
    updateStatus(`Cannot pass. You must play a stacking card or Draw to accept the penalty.`);
    return;
  }

  const hand = state.players[state.currentPlayer];
  const playable = hand.some(c => legalPlay(c));
  if(playable){
    updateStatus("You have a playable card — you cannot pass.");
    return;
  }
  
  const playerName = state.currentPlayer === 'p1' ? 'Player 1' : 'Player 2';
  logMsg(`${playerName} passed`);

  if (state.gameMode === 'pvc') {
    passTurnToCPU();
  } else {
    if (state.currentPlayer === 'p1') passTurnToP2();
    else passTurnToP1();
  }
});

el.hintBtn.addEventListener('click',()=>{
  const hand = state.players[state.currentPlayer];
  
  if(state.pendingDraw > 0) {
    const top = state.discard[state.discard.length-1];
    let stackable = null;
    
    if (top.rank === 'D2') {
       stackable = hand.find(c => c.rank === 'D2');
       if (!stackable && state.stackWD4onD2) {
          stackable = hand.find(c => c.rank === 'WD4');
       }
    }
    
    if(stackable) {
      updateStatus(`Hint: play ${cardLabel(stackable)} to stack the penalty.`);
    } else {
      updateStatus(`Hint: no stackable card. You must Draw to accept the penalty.`);
    }
    return;
  }

  let h = hand.find(c => legalPlay(c) && !isWildCard(c));
  if (!h) h = hand.find(c => legalPlay(c));

  updateStatus(h?`Hint: play ${cardLabel(h)}`:'Hint: no playable cards. Draw or Pass.');
});

el.cpuSpeedBtn.addEventListener('click',()=>{
  state.speedIndex = (state.speedIndex + 1) % SPEEDS.length;
  const s = SPEEDS[state.speedIndex];
  state.cpuPlayDelay = s.delay;
  el.cpuSpeedBtn.textContent = `CPU: ${s.label}`;
});

el.shuffleBtn.addEventListener('click',()=>{
  if(state.discard.length<=1){updateStatus("Not enough discard");return;}
  const top=state.discard.pop();
  state.deck=shuffle(state.deck.concat(state.discard));
  state.discard=[top];
  renderAll();
  logMsg('Shuffled discard into deck.');
});

el.drawPile.addEventListener('click',()=>el.drawBtn.click());

el.settingsBtn.addEventListener('click', () => {
  el.gameModeSelect.value = state.gameMode;
  el.gameVariantSelect.value = state.gameVariant; // Updated to select
  el.initialHandSizeSelect.value = state.initialHandSize.toString();
  el.reverseSkipChk.checked = state.reverseSkip;
  el.stackWD4Chk.checked = state.stackWD4onD2;
  el.mustPlayIfAbleChk.checked = state.mustPlayIfAble;
  el.drawUntilPlayableChk.checked = state.drawUntilPlayable;
  el.allowPassChk.checked = state.allowPass;
  el.firstTurnRuleSelect.value = state.firstTurnRule;
  
  toggleSettingsVisibility(state.gameVariant);
  el.settingsModal.classList.add('visible');
});

el.gameVariantSelect.addEventListener('change', () => {
    toggleSettingsVisibility(el.gameVariantSelect.value);
});

function toggleSettingsVisibility(variant) {
    if (variant === 'c8') {
        el.c8UnoSettings.style.display = 'block';
        el.reverseSkipLabel.style.display = 'none';
        el.stackWD4Label.style.display = 'none';
        el.initialHandSizeSelect.parentElement.style.display = 'flex';
        el.gameModeContainer.style.display = 'flex';
    } else if (variant === 'uno') {
        el.c8UnoSettings.style.display = 'block';
        el.reverseSkipLabel.style.display = 'flex';
        el.stackWD4Label.style.display = 'flex';
        el.initialHandSizeSelect.parentElement.style.display = 'flex';
        el.gameModeContainer.style.display = 'flex';
    } else if (variant === 'war') {
        // Hide most C8/Uno settings for War
        el.c8UnoSettings.style.display = 'none';
        // Hide PvP option for War
        el.gameModeContainer.style.display = 'none';
    }
}

el.cancelSettingsBtn.addEventListener('click', () => {
  el.settingsModal.classList.remove('visible');
});

el.applySettingsBtn.addEventListener('click', () => {
  state.gameVariant = el.gameVariantSelect.value;
  
  // Force PVC if War
  if (state.gameVariant === 'war') {
      state.gameMode = 'pvc';
  } else {
      state.gameMode = el.gameModeSelect.value;
  }

  state.initialHandSize = parseInt(el.initialHandSizeSelect.value);
  state.unoMode = state.gameVariant === 'uno'; // Compatibility
  state.reverseSkip = el.reverseSkipChk.checked;
  state.stackWD4onD2 = el.stackWD4Chk.checked;
  state.mustPlayIfAble = el.mustPlayIfAbleChk.checked;
  state.drawUntilPlayable = el.drawUntilPlayableChk.checked;
  state.allowPass = el.allowPassChk.checked;
  state.firstTurnRule = el.firstTurnRuleSelect.value;
  
  el.settingsModal.classList.remove('visible');
  startGame(true);
});

el.rulesBtn.addEventListener('click', () => {
  el.rulesC8.style.display = 'none';
  el.rulesUNO.style.display = 'none';
  el.rulesWar.style.display = 'none';
  
  if(state.gameVariant === 'uno') {
    el.rulesUNO.style.display = 'block';
  } else if(state.gameVariant === 'war') {
    el.rulesWar.style.display = 'block';
  } else {
    el.rulesC8.style.display = 'block';
  }
  el.rulesModal.classList.add('visible');
});

el.closeRulesBtn.addEventListener('click', () => {
  el.rulesModal.classList.remove('visible');
});

el.logToggle.addEventListener('click', toggleLog); // Use the mobile toggle for log access
el.statusToggle.addEventListener('click', toggleStatus); // Use the mobile toggle for status access

// Allow desktop users to click the preview to open the full log too.
if (window.innerWidth > 980) {
    el.logPreview.addEventListener('click', () => {
      el.logModal.classList.add('visible');
    });
}


el.closeLogBtn.addEventListener('click', () => {
  el.logModal.classList.remove('visible');
});

el.endGameNewGameBtn.addEventListener('click', () => {
  el.endGameModal.classList.remove('visible');
  startGame();
});

el.closeWarningBtn.addEventListener('click', () => {
    el.warningModal.classList.remove('visible');
});

function startGame(settingsChanged = false){
  if(settingsChanged) {
    state.lastWinner = null;
  }
  
  state.gameMode = (state.gameVariant === 'war') ? 'pvc' : el.gameModeSelect.value;
  
  el.endGameModal.classList.remove('visible');
  el.suitPickerModal.classList.remove('visible'); 
  el.handOverModal.classList.remove('visible');
  el.warningModal.classList.remove('visible');

  state.deck=makeDeck();
  
  if (state.gameVariant === 'war') {
      // War: Deal whole deck
      const mid = Math.floor(state.deck.length / 2);
      state.players.p1 = state.deck.slice(0, mid);
      state.players.p2 = state.deck.slice(mid);
      state.warPot = [];
      state.warActive = {p1: null, p2: null};
      state.warState = 'idle';
      state.discard = []; // Unused in War
      state.currentPlayer = 'p1'; // Manual start
      el.warLastResult.textContent = '';
  } else {
      state.players.p1=state.deck.splice(0,state.initialHandSize);
      state.players.p2=state.deck.splice(0,state.initialHandSize);
      state.pendingDraw = 0;
      state.penaltyAttemptCount = 0;
      state.isPickingSuit = false;

      let first; 
      do {
        if(state.deck.length === 0) state.deck = makeDeck();
        first=state.deck.shift();
        if (first) {
          state.discard=[first];
        } else {
          state.deck = makeDeck(); 
          first = state.deck.shift();
          state.discard = [first];
        }
      } while(first.rank==='8'||first.rank==='WILD'||first.rank==='WD4'|| (state.gameVariant === 'uno' && ['SKIP','REV','D2'].includes(first.rank)));
      
      state.currentSuit=first.suit||first.color;
      state.currentColor=first.color||first.suit;
      
      let firstPlayer = 'p1';
      switch (state.firstTurnRule) {
        case 'p2':
          firstPlayer = 'p2';
          break;
        case 'random':
          firstPlayer = Math.random() < 0.5 ? 'p1' : 'p2';
          break;
        case 'loser':
          if (state.lastWinner === 'p1') firstPlayer = 'p2';
          else if (state.lastWinner === 'p2') firstPlayer = 'p1';
          else firstPlayer = Math.random() < 0.5 ? 'p1' : 'p2';
          break;
        case 'p1':
        default:
          firstPlayer = 'p1';
          break;
      }
      state.currentPlayer = firstPlayer;
  }

  state.uiLocked = false;
  el.logPreview.innerHTML='';
  el.fullLog.innerHTML='';
  el.fullLogContent.innerHTML='';

  if (window.innerWidth <= 980) {
      el.logContent.classList.add('collapsed');
      el.logChevron.textContent = '▼';
      el.statusContent.classList.add('collapsed');
      el.statusChevron.textContent = '▼';
      el.statusContent.style.display = 'none'; 
      el.fullLogContent.style.display = 'none'; 
  } else {
      el.statusContent.style.display = 'block'; 
  }


  const startMsg = state.gameVariant === 'war' ? 'War started. Click deck to battle.' : `Game started. Top: ${cardLabel(state.discard[0])}. ${state.gameVariant === 'uno' ? 'Color' : 'Suit'}: ${state.currentSuit}`;
  logMsg(startMsg);
  
  if (state.gameVariant === 'war') {
      renderAll();
      updateStatus("War Mode: Click your deck to flip cards.");
      return;
  }

  if (state.currentPlayer === 'p1') {
    showP1Hand(true);
    updateStatus("Player 1's turn.");
  } else {
    state.currentPlayer = 'p2';
    if (state.gameMode === 'pvc') {
      state.uiLocked = true;
      renderAll();
      renderHand(el.playerHand, state.players.p1, true);
      updateStatus("CPU's turn.");
      el.opponentInfo.textContent = "playing...";
      setTimeout(cpuTurn, state.cpuPlayDelay);
    } else {
      state.uiLocked = true;
      renderAll();
      renderHand(el.playerHand, state.players.p1, true);
      el.playerHand.style.opacity = 0;
      el.handOverMessage.textContent = "Start game! Pass to Player 2. Click OK."
      el.handOverModal.classList.add('visible');
      el.handOverBtn.onclick = () => showP2Hand(true);
    }
  }
}

startGame();
</script>
</body>
</html>
